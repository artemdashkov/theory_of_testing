# Базовая теория
## Как писать код, принципы разработки программного кода
есть разные принципы SOLID, KISS, DRY
### Принцип DRY (Don't Repeat Yourself)
DRY — это принцип разработки программного обеспечения, который способствует уменьшению дублирования кода. Главная идея заключается в том, чтобы каждая часть вашей программы имела одно, единственное, и четкое представление, что способствует уменьшению ошибок и упрощению поддержки кода.

**Примеры применения DRY в Python:**
- `Функции` - Вместо повторения одного и того же кода в разных местах, выносите его в функцию.
- `Классы и наследование` - Используйте классы для группировки методов и свойств, чтобы избежать дублирования.
- `Конфигурационные файлы:` - Вместо повторения данных, храните параметры в одном месте (например, конфигурационные файлы).

### Принцип KISS (Keep It Simple, Stupid)
KISS — это принцип, который призывает к тому, чтобы системы или код были простыми. Избегайте ненужной сложности, так как она затрудняет понимание и поддержку кода.
Примеры применения KISS в Python:
- `Чистый и простой код` - Пишите функции, которые выполняют одну задачу.
- `Избегайте излишней логики:` - Если возможно, используйте встроенные функции вместо написания сложных алгоритмов.
- `Понятные имена:` - Названия переменных и функций должны отражать их суть.
- `Лаконичные конструкции:` - Используйте простые и лаконичные конструкции, такие как list comprehensions, для легкости чтения.

### Принцип SOLID
Принцип SOLID — это набор пяти основных принципов объектно-ориентированного проектирования, которые помогают создавать более гибкие и поддерживаемые программные системы. Эти принципы способствуют улучшению архитектуры кода, упрощению его тестирования и снижают риск возникновения ошибок. 
1. `S: Single Responsibility Principle (SRP)` – Принцип единственной ответственности. Каждый класс должен иметь только одну причину для изменения. Это означает, что класс должен быть сфокусирован на выполнении одной задачи.
2. `O: Open/Closed Principle (OCP)` – Принцип открытости/закрытости
Классы должны быть открыты для расширения, но закрыты для модификации. Это означает, что поведение класса можно изменять, не изменяя его исходный код.
3. `L: Liskov Substitution Principle (LSP)` – Принцип подстановки Лисков. Объекты подкласса должны быть заменяемыми на объекты суперкласса без нарушения правильности программы.
4. `I: Interface Segregation Principle (ISP)` – Принцип разделения интерфейса. Клиенты не должны зависеть от интерфейсов, которые они не используют. Это означает, что лучше иметь несколько специализированных интерфейсов, чем один общий.
5. `D: Dependency Inversion Principle (DIP)` – Принцип инверсии зависимостей. Высокоуровневые модули не должны зависеть от низкоуровневых; оба типа модулей должны зависеть от абстракций.



## Prioritize features to test based on the following factors:
- Recent—New features, new areas of code, new functionality that has been recently repaired, refactored, or otherwise modified
- Core—Your product’s unique selling propositions (USPs). The essential functions that must continue to work in order for the product to be useful
- Risk—Areas of the application that pose more risk, such as areas important to customers but not used regularly by the development team or parts that use third-party code you don’t quite trust
- Problematic—Functionality that frequently breaks or often gets defect reports against it
- Expertise—Features or algorithms understood by a limited subset of people report

### cards --help
- Usage: cards [OPTIONS] COMMAND [ARGS]...
Cards is a small command line task tracking application.
Options:
--help Show this message and exit.
**Commands**:
- `add` Add a card to db.
- `config` List the path to the Cards db.
- `count` Return number of cards in db.
- `delete` Remove card in db with given id.
- `finish` Set a card state to 'done'.
- `list` List cards in db.
- `start` Set a card state to 'in prog'.
- `update` Modify a card in db with given id with new info.
- `version` Return version of cards application

### Creating Test Cases
- Start with a non-trivial, “happy path” test case
- Then look at test cases that represent
    - interesting sets of input,
    - interesting starting states,
    - interesting end states, or
    - all possible error states.

### When writing automated tests, these are common mistakes:
- Only writing happy path test cases
- Spending too much time thinking about how things can go wrong
- Ignoring how behaviors change based on system or component state


# Виды тестирования
Существует множество видов тестирования программного обеспечения, и каждый из них служит своей конкретной цели. Вот основные категории тестирования:

1. Функциональное тестирование
    Проверяет, выполняет ли программное обеспечение свои функции в соответствии с требованиями. Включает:
    Модульное тестирование: Тестирование отдельных модулей или компонентов.
    Интеграционное тестирование: Проверка взаимодействия между различными модулями.
    Системное тестирование: Проверка всей системы в целом.
    Приемочное тестирование: Подтверждение, что ПО соответствует требованиям заказчика и готово к использованию.
2. Нефункциональное тестирование
    Оценивает аспекты, не связанные напрямую с функциональностью, такие как производительность, безопасность и удобство использования. Включает:
    Тестирование производительности: Измеряет скорость, отклик, время загрузки и устойчивость под нагрузкой.
    Тестирование безопасности: Идентифицирует уязвимости и проверяет защиту данных.
    Тестирование удобства использования (юзабилити): Оценивает, насколько легко и удобно использовать приложение.
3. Автоматизированное тестирование
    Использует инструменты и скрипты для автоматизации процесса тестирования. Это может включать автоматизацию функционального тестирования, нагрузочного тестирования и регрессионного тестирования.
4. Ручное тестирование
    Выполняется вручную тестировщиками, которые проверяют функциональность приложения, интерфейс и пользовательский опыт.
5. Регрессионное тестирование
    Проверка того, что новые изменения или исправления не вызвали новых дефектов в уже существующих функциях.
6. Тестирование совместимости
    Оценивает, как ПО работает на различных устройствах, операционных системах, браузерах и конфигурациях.
7. Тестирование локализации
    Проверяет, насколько хорошо ПО адаптировано для конкретного региона или языка, включая интерфейс, форматы даты и времени, денежные единицы и т. д.
8. Тестирование стресса
    Оценивает, как система работает в условиях экстремальных нагрузок, чтобы выявить пределы ее производительности.
9. Тестирование доступности
    Проверяет, насколько приложение доступно для пользователей с ограниченными возможностями.
10. Тестирование на основе рисков
    Фокусируется на идентификации и проверке наиболее критических для бизнеса функций и возможных рисков.
11. Тестирование данных
    Проверка правильности и целостности данных, особенно в системах, работающих с большими объемами информации.
12. Смок-тестирование
    один из видов тестирования, который используется для быстрой проверки базовой функциональности приложения. Оно часто выполняется после сборки нового ПО с целью убедиться, что основные функции работают корректно и система готова к более глубокому тестированию. Цель: Убедиться, что критически важные функции приложения функционируют. Это как бы "поверхностная" проверка, которая помогает быстро определить, можно ли продолжать с более детальным тестированием.

# Задача автотестов
в том, чтобы во время сигнализировать о проблеме и влиять на процесс доставки продукта в продакшн